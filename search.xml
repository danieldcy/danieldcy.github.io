<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[洛谷P3209]平面图判定 题解</title>
      <link href="/post/lg-P3209/"/>
      <url>/post/lg-P3209/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>若能将无向图 $G=(V,E)$ 画在平面上使得任意两条无重合顶点的边不相交，则称 $G$ 是平面图</p><p>判定一个图是否为平面图的问题是图论中的一个重要问题</p><p>现在假设你要判定的是一类特殊的图，图中存在一个包含所有顶点的环，即存在哈密顿回路</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入文件的第一行是一个正整数 $T$ ，表示数据组数 (每组数据描述一个需要判定的图)。</p><p>接下来从输入文件第二行开始有 $T$ 组数据</p><p>每组数据的第一行是用空格隔开的两个正整数 $N$ 和 $M$ ，分别表示对应图的顶点数和边数</p><p>紧接着的 $M$ 行，每行是用空格隔开的两个正整数 $u$ 和 $v$ $\left(1\leq u,v\leq N\right)$，表示对应图的一条边 $\left(u,v\right)$ </p><p>输入的数据保证所有边仅出现一次</p><p>每组数据的最后一行是用空格隔开的 $N$ 个正整数，从左到右表示对应图中的一个哈密顿回路$V_1,V_2,\cdots,V_N$</p><p>即对任意 $i\not=j$ 有 $V_i\not=V_j$ 且对任意 $1\leq i\leq N-1$ 有 $\left(V_i,V_i-1\right)\in E$ 及 $\left(V_1,V_N\right)\in E$</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>输入的数据保证 $100\%$ 的数据满足 $T\leq100,3\leq N\leq200,M\leq10000$</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>包含 $T$ 行，若输入文件的第 $i$ 组数据所对应图是平面图，则在第 $i$ 行输出 $\text{YES}$，否则在第 $i$ 行输出 $\text{NO}$，注意均为大写字母</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>好了，看完了<del>巨长无比</del>的题面，我们的第一想法肯定是<strong>画个图看看</strong></p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/20200809211703.png" alt="平面图示例" style="zoom:67%;" /></p><p>对于这张图，$1\rightarrow2\rightarrow3\rightarrow4\rightarrow5\rightarrow6$ 显然是一个<del>畸形的</del>哈密顿回路</p><p>而$1\rightarrow3$ ，$4\rightarrow6$ ，$5\rightarrow1$ 这三条边并没有与其它边相交</p><p>所以…这是一个符合题意的图！（惊喜</p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/20200809212413.png" alt="不可能成为平面图的示例" style="zoom:67%;" /></p><p>而对于第二张图，无论这几条边怎么组合，都不可能不相交（不信你试试</p><p>所以这张图就是一个 $\text{NO}$</p><p><strong>OVER</strong></p><p>但是我们该怎么用程序实现呢</p><p>容易发现，题目给了一个非常有用的限制条件</p><blockquote><p>“<strong>哈密顿回路</strong>”</p></blockquote><p>一个环会将平面分成两个部分：环内和环外<del>（废话</del></p><p>因此，一条边的位置也只有3种可能：环内，环上，环外</p><p>除去组成环的边，我们就只剩下了<strong>两种可能</strong></p><p><del>这™不就是<strong>2-SAT</strong>的定义吗…</del></p><p>好</p><p>我们想一下怎么建图</p><p>首先我们定义两条边是<strong>不相容的</strong>（随手起的</p><p>当且仅当它们不可能同为以上两种可能的一种</p><p>举个🌰</p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/20200811131255.png" alt="不相容的例子" style="zoom: 50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 图论题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解2-SAT</title>
      <link href="/post/2-SAT/"/>
      <url>/post/2-SAT/</url>
      
        <content type="html"><![CDATA[<p><del>众所周知</del>，2-SAT是判断一组逻辑关系是否可能成立的重要算法，适用范围十分广泛。</p><p>那么2-SAT是怎么一回事呢，<del>下面就让小编带大家一起了解一下吧</del></p><h2 id="2-SAT是什么？能吃吗（期待"><a href="#2-SAT是什么？能吃吗（期待" class="headerlink" title="2-SAT是什么？能吃吗（期待"></a>2-SAT是什么？能吃吗（期待</h2><p>2-SAT是2-Satisfiability（<strong>双重可能性的可实现性问题</strong>）的简称<del>（英语蒟蒻落泪）</del>。</p><p>然而wtcl，所以这个定义我还是看不懂（摊手）</p><p>于是让我们举个生活中栗子🌰康康</p><blockquote><p><del>AKIOI的奆佬</del>zxy和他的好 朋 友们要一起上一样的选修课，可供选择的有数学，物理，化学，信息，<del>道法</del>等科目（雾</p><p>可<del>奆佬们</del>比较挑剔，都有自己的喜好</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th><del>奆佬</del>的要求</th></tr></thead><tbody><tr><td style="text-align:center">zxy</td><td>我爱数学！我一定要上数学！</td></tr><tr><td style="text-align:center">z**</td><td>众所周知，学不好数学就一定学不好物理（大雾。所以，我如果上物理，就一定要上数学！</td></tr><tr><td style="text-align:center">l**</td><td>额，我精 力 有 限，所以我如果上信息就不能上化学了</td></tr><tr><td style="text-align:center">w**</td><td>我对物理和化学一样感兴趣，所以要上他们两个要一起上！</td></tr></tbody></table></div></blockquote><p>明白了？奆佬们可以去上数学，物理和化学（当然解法不止一种），<del>真的tql</del>（超大雾</p><p>这种讨论适定性的问题，便是2-SAT问题</p><p><del>然而怎么可能这么简单呢</del></p><h2 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h2><p>一般来说，2-SAT问题的形式如下：</p><blockquote><p>给定M个限定条件（通常为<strong>与、或、异或</strong>中一个），求出是否有满足的选择/排列方式（并输出）</p></blockquote><h2 id="建模方法"><a href="#建模方法" class="headerlink" title="建模方法"></a>建模方法</h2><p>终于来到激动人心的环节了（搓手）</p><p>对于此类问题，我们一般采取建模（即<strong>建图</strong>）的方法解决，其中每个点对应一个状态</p><p>我们不难看出鉴于每个东西只可能有2种情况（0或1）[<strong>2-SAT定义</strong>]，可以将每个$a_i$<strong>分成两个点</strong>，其中1-n为$a_i$取1，n+1-n*2表示$a_i$取0</p><p>接下来我们分析一下各种情况对应的建图方式</p><h3 id="与"><a href="#与" class="headerlink" title="与"></a>与</h3><ul><li><p>$a_i$ &amp;&amp; $a_j$ = 1</p><p>即$a_i$、$a_j$<strong>均要为真</strong></p><p>所以建边（i+n -&gt; i）和（j+n -&gt; j）</p><p>表示<strong>无论如何都要为真，假的也能推出真的</strong>（噗嗤）</p></li><li><p>$a_i$ &amp;&amp; $a_j$ = 0</p><p>即$a_i$、$a_j$中<strong>最多有一个</strong>为真</p><p>所以建边（i -&gt; j+n）和（j -&gt; i+n）</p><p>表示<strong>j真则i假，i真则j假</strong></p></li></ul><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><ul><li><p>$a_i$ || $a_j$ = 1</p><p>即$a_i$、$a_j$中<strong>至少有一个</strong>为真</p><p>所以建边（i+n -&gt; j）和（j+n -&gt; i）</p><p>表示<strong>j假则i真，i假则j真</strong></p></li><li><p>$a_i$ || $a_j$ = 0</p><p>即$a_i$、$a_j$<strong>均为假</strong></p><p>所以建边（i -&gt; i+n）和（j -&gt; j+n）</p><p>表示<strong>无论如何都要为假，真的也能推出假的</strong></p></li></ul><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>​    首先先明确，异或即为比较相不相同，相同为0，不相同为1</p><ul><li><p>$a_i$ ^ $a_j$ = 1</p><p>即$a_i$、$a_j$状态<strong>互不相同</strong></p><p>那就简单了，建边（i -&gt; j+n）、（j -&gt; i+n）、（i+n -&gt; j）、（j+n -&gt; i）</p></li><li><p>$a_i$ ^  $a_j$ = 0</p><p>即$a_i$、$a_j$的状态<strong>一 模 一 样</strong></p><p>所以建边（i -&gt; j）、（j -&gt; i）、（i+n -&gt; j+n）、（j+n -&gt; i+n）</p></li></ul><p>​    此时我们注意到，异或的连边都是<strong>双向边</strong>。</p><p>​    这也不难理解，异或在此处是表示相同 / 不同的关系，双方是完全对等的</p><p>​    重点是，此时我们便可以用一个更 简 单的算法来解决这种关系了… <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">并查集</span></span></p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/a13pc9.png" alt="关系图事例"  /></p><p>好了，讲了这么多，<del>聪明的你</del>能不能写出上图对应的逻辑关系式呢…</p> <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">(a || (!c)) && (a ^ b == 0)</span></span><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p><strong>普通的有向图，不好操作！</strong></p><p><strong>我们缩点后的DAG，好操作！</strong></p></blockquote><p>对于有向图，我们常用的技巧是用<strong>Tarjan</strong>算法进行缩点，可以缩成一个DAG（<strong>有向无环图</strong>）</p><p>等等</p><p>“<strong>为什么要缩点啊</strong>”</p><p>上图</p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/Tarjan2.png" alt="Tarjan&#39;s Algorithm to find Strongly Connected Components"></p><p>如图，(1,2,3)、(4)、(5,6,7,8)都是一个强连通分量</p><p>此时，这三个分量中的每个点都<strong>必定状态相同</strong></p><p>所以只要<strong>有一个条件为真，分量中所有的条件都一定为真</strong>，反之亦然</p><p>所以如果$(A)$ 和$(\lnot A)$在同一个块里…那不就矛盾了吗？？！</p><h3 id="问-题-解-决"><a href="#问-题-解-决" class="headerlink" title="问 题 解 决"></a>问 题 解 决</h3><p>再等等</p><p>“<strong>怎么缩点啊</strong>”</p><p>前文已提到利用<strong>Tarjan</strong>算法，这里不再赘述，给出标程。<del>（不会的自己学去</del></p><p>时间复杂度 $O(n+m)$ ，是优秀的线性算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low[N],dfn[N],scc[N],tot,cnt;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++tot;<span class="comment">//遍历到新点</span></span><br><span class="line">    st.push(x);<span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=e[i].to)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;<span class="comment">//枚举相连的点</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;<span class="comment">//没走过</span></span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y])&#123;<span class="comment">//在栈里</span></span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])&#123;<span class="comment">//形成强连通分量</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span>(st.top()!=x)&#123;<span class="comment">//出栈</span></span><br><span class="line">            scc[st.top()]=cnt;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        scc[st.top()]=cnt;<span class="comment">//同上</span></span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>是不是简单明了小清新呢</del></p><h2 id="方案输出"><a href="#方案输出" class="headerlink" title="方案输出"></a>方案输出</h2><p>有时，<del>毒瘤出题人</del>会让我们输出满足题意的方案</p><p>如果我们观察缩完点的图，会不难发现它是一个<strong>DAG</strong></p><blockquote><p>“<strong>DAG好啊</strong>“ ——某巨佬</p></blockquote><p>DAG一跑拓扑排序不就什么都有了吗…</p><p>但是我们在跑Tarjan的时候就有个结论</p><p><strong>SCC出栈的顺序即为缩点后图拓扑序的倒序</strong></p><p>所以连这步都省了</p><p>仔细想一想</p><p>拓扑序在后面的一定<strong>依赖</strong>在前面的</p><p>即前面的为真的就一定能推出后面的为真的</p><p>而对于点$(A)$ 和$(\lnot A)$，他们的状态<strong>必定相反</strong></p><p>所以一定是真的在后，假的在前</p><p>换成Tarjan中得出栈顺序就得到了：</p><p><strong>所在SCC编号小的为真，大的为假</strong></p><p>参考代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(scc[i]==scc[i+n]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//在同一个强连通分量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//都不在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(scc[i]&lt;scc[i+n]) <span class="built_in">printf</span>(<span class="string">&quot;%d 1\n&quot;</span>,i);<span class="comment">//编号小的为真</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d 0\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-amp-题解"><a href="#例题-amp-题解" class="headerlink" title="例题 &amp; 题解"></a>例题 &amp; 题解</h2><p><a href="/post/lg-P4171">洛谷P4171 满汉全席</a></p><p>日后再更</p>]]></content>
      
      
      <categories>
          
          <category> 图论算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[洛谷P4171]满汉全席 题解</title>
      <link href="/post/lg-P4171/"/>
      <url>/post/lg-P4171/</url>
      
        <content type="html"><![CDATA[<p><del>我饿了</del>（误</p><p><a href="https://www.luogu.com.cn/problem/P4171">传送门</a></p><p><del>反手切一道紫题，闷声发大财</del></p><p>不开玩笑了</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有 $n$ 种材料，$m$个要求，其中每个要求中的两个小要求 <del>（好绕啊</del> 必须满足至少一个（也就是<strong>或</strong>）</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难看出，对于每种材料只有两种可能，即 满式 和 汉式</p><p>因此，这题可以用<strong>2-SAT</strong>!</p><p>不懂的可以来我的<a href="/post/2-SAT">这篇博客</a>学习</p><p><del>然后就是考你模板背的熟不熟了</del></p><p>对了</p><p>输入要注意一下</p><p>快读党可能得微调一下读入的函数</p><p>其它就没啥了</p><p>上 代 码</p><h2 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星，不想解释</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> last[N],cnt;</span><br><span class="line"><span class="comment">//建边操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].next=last[x];</span><br><span class="line">    e[cnt].to=y;</span><br><span class="line">    last[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">char</span> c1,c2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Tarjan模板</span></span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],scc[N],dcnt,icnt;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    st.push(x);</span><br><span class="line">    dfn[x]=low[x]=++dcnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[x];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!scc[y])&#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        icnt++;</span><br><span class="line">        <span class="keyword">while</span>(st.top()!=x)&#123;</span><br><span class="line">            scc[st.top()]=icnt;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        scc[st.top()]=icnt;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;k);</span><br><span class="line">    <span class="comment">//多组数据</span></span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="comment">//建边前初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1-n表示满式做法，n+1-2*n为汉式做法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="comment">//用scanf格式化输入就是香…</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c%d %c%d\n&quot;</span>,&amp;c1,&amp;x,&amp;c2,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(c1==<span class="string">&#x27;m&#x27;</span>&amp;&amp;c2==<span class="string">&#x27;m&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//一个是汉式，另一个就要是满式</span></span><br><span class="line">                add_edge(x+n,y);add_edge(y+n,x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c1==<span class="string">&#x27;m&#x27;</span>&amp;&amp;c2==<span class="string">&#x27;h&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//1为汉式，2就要为汉式；反之亦然</span></span><br><span class="line">                add_edge(x+n,y+n);add_edge(y,x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c1==<span class="string">&#x27;h&#x27;</span>&amp;&amp;c2==<span class="string">&#x27;m&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//同上</span></span><br><span class="line">                add_edge(x,y);add_edge(y+n,x+n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//一个是满式，则另一个为汉式</span></span><br><span class="line">                add_edge(y,x+n);add_edge(x,y+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩点前初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));<span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));<span class="built_in">memset</span>(scc,<span class="number">0</span>,<span class="keyword">sizeof</span>(scc));</span><br><span class="line">        <span class="comment">//图不一定连通…注意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(scc[i]==scc[i+n]) &#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;GOOD\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;BAD\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上热乎的AC记录…</p><p><img src= "https://gitee.com/danieldcy/img/raw/master/img/20200809150620.gif" data-lazy-src="https://gitee.com/danieldcy/img/raw/master/img/20200808221536.jpeg" alt="AC啦"></p><p>最后提醒一下</p><p><strong>不要抄题解</strong></p><p><strong>不要抄题解</strong></p><p><strong>不要抄题解</strong></p><p>不然…棕名等着你哦（滑稽</p>]]></content>
      
      
      <categories>
          
          <category> 图论题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
            <tag> 题解 </tag>
            
            <tag> 缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试hexo新博客</title>
      <link href="/post/test/"/>
      <url>/post/test/</url>
      
        <content type="html"><![CDATA[<script type="math/tex; mode=display">\lim_{n\rightarrow\infty}\sum_{k=1}^n\frac{1}{k^2}=\frac{\pi^2}{6}</script><h3 id="很有意思"><a href="#很有意思" class="headerlink" title="很有意思"></a>很有意思</h3><p><del>不是</del> <strong>hhhh</strong> </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">1.0</span>*n,<span class="number">1.0</span>/m))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> none </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 测验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
